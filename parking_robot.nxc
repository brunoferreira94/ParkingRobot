#define speed 40
#define low_speed 30
#define COLOR_SENSOR IN_3
#define USONIC_FRONT IN_4
#define USONIC_BACK IN_2
#define USONIC_LEFT IN_1

int flag_inicio = 0, color, colorval, cont, oldDistance, newDistance, diferenca = 5;
float distance, distance_back, spaceBtwBoxes, boxBegin, boxEnd;
float diamRoda = 9.425;
unsigned int raw[], norm[], scaled[];

//FUNÇÃO PARA SEGUIR A LINHA RETA PRETA
void ForwardOnBlackLine(){
     color = ReadSensorColorEx(COLOR_SENSOR,colorval,raw,norm,scaled);

        //if(scaled[0]<120 && scaled[1]<100 && scaled[2]<100)
        if(colorval <= 2)
        {
            OnFwd(OUT_AC,speed);
        }
        else{
            cont = 0;
            while(colorval > 2 && cont < 2){
                OnRev(OUT_A, low_speed);
                OnRev(OUT_C, -low_speed);
                Wait(25);
                color = ReadSensorColorEx(COLOR_SENSOR,colorval,raw,norm,scaled);
                cont++;
            }
            cont = 0;
            while(colorval > 2 && cont < 4){
                OnRev(OUT_A, -low_speed);
                OnRev(OUT_C, low_speed);
                Wait(25);
                color = ReadSensorColorEx(COLOR_SENSOR,colorval,raw,norm,scaled);
                cont++;
            }
        }

        distance = SensorUS(USONIC_LEFT);
        distance_back = SensorUS(USONIC_BACK);
}

//TAREFA PRINCIPAL
task main()
{

    //Ligar os sensores em suas respectivas entradas
    SetSensorColorFull(COLOR_SENSOR);
    SetSensorLowspeed(USONIC_FRONT);
    SetSensorLowspeed(USONIC_BACK);
    SetSensorLowspeed(USONIC_LEFT);

    color = ReadSensorColorEx(COLOR_SENSOR,colorval,raw,norm,scaled);
    distance = SensorUS(USONIC_LEFT);
    distance_back = SensorUS(USONIC_BACK);
    //OBTÉM A PRIMEIRA DISTÂNCIA DO SENSOR
    oldDistance = distance;

    while(flag_inicio < 3)
    {
        ForwardOnBlackLine();
        //OBTÉM A ATUAL DISTÂNCIA
        newDistance = SensorUS(USONIC_LEFT);
        //SE A DIFERENÇA ENTRE A ATUAL DISTÂNCIA E A PRIMEIRA DISTÂNCIA FOR MAIOR QUE 5 EM VALOR ABSOLUTO, ANDA 500 MS PARA FRENTE
        if(abs(oldDistance - newDistance) > diferenca && flag_inicio == 0){
            ClearScreen();
            TextOut(0,0, "FLAG 1");
            flag_inicio = 1;
            OnFwd(OUT_AC, low_speed);
            Wait(2000);
            oldDistance = SensorUS(USONIC_LEFT);
        }

        //OBTÉM A ATUAL DISTÂNCIA
        newDistance = SensorUS(USONIC_LEFT);
        //SE A DIFERENÇA ENTRE A ATUAL DISTÂNCIA E A PRIMEIRA DISTÂNCIA FOR MAIOR QUE 5 EM VALOR ABSOLUTO, OBTÉM A CONTAGEM DA ROTAÇÃO DO MOTOR
        if(abs(oldDistance - newDistance) > diferenca && flag_inicio == 1){
            oldDistance = newDistance;
            boxBegin = MotorRotationCount(OUT_A);
            ClearScreen();
            TextOut(0,0, "FLAG 2");
            flag_inicio = 2;
        }

        //OBTÉM A ATUAL DISTÂNCIA
        newDistance = SensorUS(USONIC_LEFT);
        //SE A DIFERENÇA ENTRE A ATUAL DISTÂNCIA E A PRIMEIRA DISTÂNCIA FOR MAIOR QUE 5 EM VALOR ABSOLUTO, OBTÉM A DISTÂNCIA ENTRE AS DUAS CAIXAS EM CM
        if(abs(oldDistance - newDistance) > diferenca && flag_inicio == 2){
            oldDistance = newDistance;
            boxEnd = MotorRotationCount(OUT_A);
            spaceBtwBoxes = (boxEnd - boxBegin)*diamRoda;
            //SE A DISTÂNCIA ENTRE AS CAIXAS FOR MENOR QUE 15, DESLIGA O ROBÔ
            if(spaceBtwBoxes < 15){
                while(true){
                  Off(OUT_AC);
                  Wait(1000);
                }
            }
            ClearScreen();
            TextOut(0,0, "FLAG 3");
            flag_inicio = 3;
        }

    }

    distance = SensorUS(USONIC_LEFT);
    while(flag_inicio == 3){
         distance = SensorUS(USONIC_LEFT);
         while((MotorRotationCount(OUT_A) - boxEnd) > spaceBtwBoxes/2){
              OnRev(OUT_AC, low_speed);
         }
         Off(OUT_AC);
         /*if(distance > 20){
           //Gira em sentido anti-horário
           OnRev(OUT_C,75);
           OnRev(OUT_A,-75);
           Wait(500);
           flag_inicio = 3;
          }
          */
      }

      /*cont =0;
      while(cont < 3){
           //Enquanto não estiver perto o suficiente, vá em frente
           while(SensorUS(USONIC_FRONT) > 20){
                OnFwd(OUT_AC, low_speed);
           }
           Off(OUT_AC);

           OnRev(OUT_C,75);
           OnRev(OUT_A,-75);
           Wait(500);
           Off(OUT_AC);
           cont++;
     }
     */
}
